#![deny(clippy::all)]

use napi::bindgen_prelude::*;
use napi_derive::napi;
use svg2pdf::convert_tree;
use usvg::TreeParsing;

#[napi]
pub enum Align {
  None,
  XMinYMin,
  XMidYMin,
  XMaxYMin,
  XMinYMid,
  XMidYMid,
  XMaxYMid,
  XMinYMax,
  XMidYMax,
  XMaxYMax,
}

impl From<Align> for usvg::Align {
  fn from(align: Align) -> Self {
    match align {
      Align::None => Self::None,
      Align::XMinYMin => Self::XMinYMin,
      Align::XMidYMin => Self::XMidYMin,
      Align::XMaxYMin => Self::XMaxYMin,
      Align::XMinYMid => Self::XMinYMid,
      Align::XMidYMid => Self::XMidYMid,
      Align::XMaxYMid => Self::XMaxYMid,
      Align::XMinYMax => Self::XMinYMax,
      Align::XMidYMax => Self::XMidYMax,
      Align::XMaxYMax => Self::XMaxYMax,
    }
  }
}

#[napi(object)]
pub struct AspectRatio {
  /// `<defer>` value.
  ///
  /// Set to `true` when `defer` value is present.
  pub defer: bool,
  /// `<align>` value.
  pub align: Align,
  /// `<meetOrSlice>` value.
  ///
  /// - Set to `true` when `slice` value is present.
  /// - Set to `false` when `meet` value is present or value is not set at all.
  pub slice: bool,
}

impl From<AspectRatio> for usvg::AspectRatio {
  fn from(ratio: AspectRatio) -> Self {
    usvg::AspectRatio {
      defer: ratio.defer,
      align: ratio.align.into(),
      slice: ratio.slice,
    }
  }
}

#[napi(object)]
pub struct ViewPort {
  pub width: f64,
  pub height: f64,
}

#[napi(object)]
pub struct Options {
  /// Specific dimensions the SVG will be forced to fill in nominal SVG
  /// pixels. If this is `Some`, the resulting PDF will always have the
  /// corresponding size converted to PostScript points according to `dpi`. If
  /// it is `None`, the PDF will either take on the native size of the SVG or
  /// 100 by 100 if no native size was specified (i.e. there is no `viewBox`,
  /// no `width`, and no `height` attribute).
  ///
  /// Normally, unsized SVGs will take on the size of the target viewport. In
  /// order to achieve the behavior in which your SVG will take its native
  /// size and the size of your viewport only if it has no native size, you
  /// need to create a usvg [`Tree`] for your file in your own code. You will
  /// then need to set the `default_size` field of the [`usvg::Options`]
  /// struct to your viewport size and set this field according to
  /// `tree.svg_node().size`.
  ///
  /// _Default:_ `None`.
  pub viewport: Option<ViewPort>,
  /// Override the scaling mode of the SVG within its viewport. Look
  /// [here][aspect] to learn about the different possible modes.
  ///
  /// _Default:_ `None`.
  ///
  /// [aspect]: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio
  pub aspect: Option<AspectRatio>,
  /// The dots per inch to assume for the conversion to PDF's printer's
  /// points. Common values include `72.0` (1pt = 1px; Adobe and macOS) and
  /// `96.0` (Microsoft) for standard resolution screens and multiples of
  /// `300.0` for print quality.
  ///
  /// This, of course, does not change the output quality (except for very
  /// high values, where precision might degrade due to floating point
  /// errors). Instead, it sets what the physical dimensions of one nominal
  /// pixel should be on paper when printed without scaling.
  ///
  /// _Default:_ `72.0`.
  pub dpi: Option<f64>,
  /// Whether the content streams should be compressed.
  ///
  /// The smaller PDFs generated by this are generally more practical but it
  /// increases runtime a bit.
  ///
  /// _Default:_ `true`.
  pub compress: Option<bool>,
}

impl From<Options> for svg2pdf::Options {
  fn from(options: Options) -> Self {
    svg2pdf::Options {
      viewport: options
        .viewport
        .and_then(|vp| usvg::Size::new(vp.width, vp.height)),
      aspect: options.aspect.map(|aspect| aspect.into()),
      dpi: options.dpi.map(|d| d as f32).unwrap_or(72.0),
      compress: options.compress.unwrap_or(true),
    }
  }
}

#[napi]
pub fn convert(
  input: Either3<Buffer, String, Unknown>,
  options: Option<Options>,
) -> Result<Buffer> {
  let options: svg2pdf::Options = options.map(|o| o.into()).unwrap_or_default();
  let mut usvg_opts = usvg::Options::default();
  if let Some(size) = options.viewport {
    usvg_opts.default_size =
      usvg::Size::new(size.width().max(1.0), size.height().max(1.0)).unwrap();
  }
  let tree = usvg::Tree::from_data(input.as_bytes()?, &usvg_opts)
    .map_err(|err| Error::new(Status::InvalidArg, format!("Parse SVG error {err}")))?;
  let output = convert_tree(&tree, options);
  Ok(output.into())
}

trait AsBytes {
  fn as_bytes(&self) -> Result<&[u8]>;
}

impl AsBytes for Either3<Buffer, String, Unknown> {
  fn as_bytes(&self) -> Result<&[u8]> {
    match self {
      Self::A(b) => Ok(b.as_ref()),
      Self::B(s) => Ok(s.as_bytes()),
      _ => Err(Error::new(
        Status::InvalidArg,
        "Input should be Buffer or String".to_owned(),
      )),
    }
  }
}
